soo there we go 
I am at the point where I have to generate the fractal
- I take a point on the plane (aka pixel)
- I begin top left corner, I first do the full row
then I go down and to zero again and so on
like before
ez pz
- I convert the pixel coordinates to the complex number
>>>complex.r = (px_x - x_zero) * 4 / 1000
>>>complex.i = (y_zero - px_y) * 4 / 1000
- I put number in the function and I iterate iterate
>>>I can't use the pow function, because 
- each iteration, I have some result
- I check if it's within [-2, 2]
-- if it fits in the range, I put it into function again
-- if not, I exit iterating
- I save the number of iterations
-- if iterations are > n (ex. 255), I quit iterating
- once I quit, I go to color function
if there are 255 iter, I keep stuff black
if there are less, I vary the colors accordingly

I convert pixel to complex when I reach a new pixel
I when iterating, I do not convert anymore

do I even have to go through each of the pixel? yes

I check for the number to be within two, but it doesnt affect how I change the color
the color is dependent purely on iterations

the square - math was flipped and I was iterating through the same number over and over
and also - I didn't typecast the conversion from px to complex to doubles

now I have the fractallll, so let's paint it nicely

ok, so:
I only reach the max iter if the thing doesn't escape
so I can just put the condition for coloring: if (iter == 255), don't even color and put pixel there
big redesign of the color function is necessary
there's no need to generate the pixel if it's not colored
this is the first optimazition that I can make already
<<< DONE >>>
<<< TO DO >>>
- play with the colors, make them transitions smoothly
	- use the sin function to change the colors smoothly
	- figure out how to link different coloring schemes from the CL
	1) add color_scheme to the img struct
	2) in main pass the argv[2] value to the get_started
	3) in get_started, put the argv value in the img struct
	4) pass the color_scheme (aka argv[2] to the paint_my_wrld function)
---- set one default coloring scheme in case ppl do not want to choose colors
- change the scale
	- the scale of the mandelbrot has to be the same as the scale of the screen
	- 3 : 2

./fractol Mandelbrot 
err: so, the argv[2] if doesnt ever enter
so color scheme is never set
so the bernstein shouldnt even go live

ok, enters the if, but doesnt produce colors 
I\ve no idea where the colors come from :D -----> GARBAGE VALUES :')
SO gotta figure out the math for bernstein
f i x e d - iterations were not typecasted to double

<<<TO DO>>>
- zoom into the pouse position
	-> establish mouse position (hooking there we go)
	-> make it a new... what?
- move the fractal with the arrow keys
	-> I guess the middle is then located in a different place
	-> the pixels are calculated anew according to the new centre
	-> the visible limits are changed
	-> change the limits by a percentage of the keys
	-> hook the program to wait for the arrow keys and feed them the function // let's use the same funct for all keys (for esc etc)
																				to only hook in one function
	- I only create the coordi in the mandelbrot (further than hooking functions), so I cannot 
	use it to recalculate the pixels 
	buuuut what if I put the t_coordi in the mlx ptr?
	-----did that, works fine-----t_coordi is now in the ptr struct----it's a nested struct now----
	then it's created already in the get_started. and then I can just use double -> to access the coordi
	but then I have to pass also the ptr to the mandelbrot
...hint - let the ide choose . or -> automatically 
	each key press move px pixels
	ok, compiles, but doesn't move. does it have sth to do with nested struct?
	
- exit the program when red x on the window clicked
	-> tried mlx hook ON_DESTROY - not working
	-> idk why. other ppl have this solution. could be bc it's not in main....?
- color range shift - a loop inside which bernstein colors are changed
	- entered when a key pressed
	- exited when a key pressed
- color play - the more iter, the closer the thing is
				the less iter, the faster the thing escapes
				so I want to fade these that go fast much stronger
- Julia sets
