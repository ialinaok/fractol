soo there we go 
I am at the point where I have to generate the fractal
- I take a point on the plane (aka pixel)
- I begin top left corner, I first do the full row
then I go down and to zero again and so on
like before
ez pz
- I convert the pixel coordinates to the complex number
>>>complex.r = (px_x - x_zero) * 4 / 1000
>>>complex.i = (y_zero - px_y) * 4 / 1000
- I put number in the function and I iterate iterate
>>>I can't use the pow function, because 
- each iteration, I have some result
- I check if it's within [-2, 2]
-- if it fits in the range, I put it into function again
-- if not, I exit iterating
- I save the number of iterations
-- if iterations are > n (ex. 255), I quit iterating
- once I quit, I go to color function
if there are 255 iter, I keep stuff black
if there are less, I vary the colors accordingly

I convert pixel to complex when I reach a new pixel
I when iterating, I do not convert anymore

do I even have to go through each of the pixel? yes

I check for the number to be within two, but it doesnt affect how I change the color
the color is dependent purely on iterations

the square - math was flipped and I was iterating through the same number over and over
and also - I didn't typecast the conversion from px to complex to doubles

now I have the fractallll, so let's paint it nicely

ok, so:
I only reach the max iter if the thing doesn't escape
so I can just put the condition for coloring: if (iter == 255), don't even color and put pixel there
big redesign of the color function is necessary
there's no need to generate the pixel if it's not colored
this is the first optimazition that I can make already
<<< DONE >>>
<<< TO DO >>>
- play with the colors, make them transitions smoothly
	- use the sin function to change the colors smoothly
	- figure out how to link different coloring schemes from the CL
	1) add color_scheme to the img struct
	2) in main pass the argv[2] value to the get_started
	3) in get_started, put the argv value in the img struct
	4) pass the color_scheme (aka argv[2] to the paint_my_wrld function)
---- set one default coloring scheme in case ppl do not want to choose colors
- change the scale
	- the scale of the mandelbrot has to be the same as the scale of the screen
	- 3 : 2

./fractol Mandelbrot 
err: so, the argv[2] if doesnt ever enter
so color scheme is never set
so the bernstein shouldnt even go live

ok, enters the if, but doesnt produce colors 
I\ve no idea where the colors come from :D -----> GARBAGE VALUES :')
SO gotta figure out the math for bernstein
f i x e d - iterations were not typecasted to double

<<<TO DO>>>
- zoom into the pouse position
	-> establish mouse position (hooking there we go)
	-> make it a new... what?
- move the fractal with the arrow keys
	-> I guess the middle is then located in a different place
	-> the pixels are calculated anew according to the new centre
	-> the visible limits are changed
	-> change the limits by a percentage of the keys
	-> hook the program to wait for the arrow keys and feed them the function // let's use the same funct for all keys (for esc etc)
																				to only hook in one function
	- I only create the coordi in the mandelbrot (further than hooking functions), so I cannot 
	use it to recalculate the pixels 
	buuuut what if I put the t_coordi in the mlx ptr?
	-----did that, works fine-----t_coordi is now in the ptr struct----it's a nested struct now----
	then it's created already in the get_started. and then I can just use double -> to access the coordi
	but then I have to pass also the ptr to the mandelbrot
...hint - let the ide choose . or -> automatically 
	each key press move px pixels
	ok, compiles, but doesn't move. does it have sth to do with nested struct?
	>>>> nope, I have to hook the function that renders the fractal
	mlx_loop_hook or sth like that
- exit the program when red x on the window clicked
	-> tried mlx hook ON_DESTROY - not working
	-> idk why. other ppl have this solution. could be bc it's not in main....?
- color range shift - a loop inside which bernstein colors are changed
	- entered when a key pressed
	- exited when a key pressed
- color play - the more iter, the closer the thing is
				the less iter, the faster the thing escapes
				so I want to fade these that go fast much stronger
- Julia sets

>>>redesign of structs - putting coordi and img structs into the big data struct
and in the future I can just pass this around
works after first redesign - it wasnt actually that big - I only used data in mandelbrot so far

ok, it was working until I created the render function and changed how I direct the program into sets
and now it segfaults
what's also different - I create the data struct in main, so above the mlx functions
I will try moving the mlx things to the main
and initialize in the check_set function

ok moved to main and doesn't segfault anymore XD
the window opens, but is very very laggy

it's not laggy without the render function in the mlx_loop_hook

ok nvm. I am not passing it to the hook for now.... and I've no idea why it's so laggy with my position 
changing function

what I want to do - initialize the values of the limits already in the function checking for fractals

ok, to-do's for the day:
- try to malloc the stuff
- j u l i a for the last timeeeee ugh
- try to have thing generating with another approach 
- put init somewhere else in the input checkin functions

DO SOME DUMB SHIT - just render sth else than mandelbrot

gotta fix the lagging issue :')
--->>> about that - after a talk with Constanin, apparently there's no need to keep
the rendering function in a loop - instead, just call the render function when something changes
in the key hook / mouse hook

1 - check for the set
2 - initialize the values of the edges
3 - render the fractol
4 - wait for the keys/mouse
5 - if keypressed - render again or close

and find some nicer colors for Julias
and do the Sierpinsky triangle
aaaannnddd add a key that will change the iteration value
and zooming is waiting for you ;)
ok, to finish up on the arrows - try to optimise it!
you can copy most of the pixels to a different area in the screen
and only generate the before unseen part 

so, if a key was pressed - that means you moved for x pixels to one or the other direction
then you copy from the 0,0 px of old image to x,y px of old image
and you just continue that 
and then you apply the fractal math to the rest of it

oki, the zoom in part: 
- let's start with imagining zooming in into zero. then the limits are changed proportiionally
---> let's say, every mouse wheel 

SO, learnings from Constantin:
	* for every mouse button there's a different value
		* for left click 1
		* for right click 2
		* for scroll down 4
		* for scroll up 5
		* for scroll right 6
		* for scroll left 7
	* I can get the mouse pos from the mouse_hook directly
	* it gets triggerred multiple times (the wheel)
	* the magic mouse it might be difficult - it's v sensitive

--> for each trigger I can resize the window by x%
--> I know the position of the mouse
--> I can use the position of the mouse and the new limits that I want
to calculate the percentages of how much of which scale I want to keep

img addr - all px values are there
to access them - I have to do the reverse operation
so that I can access a color from a specific position
so for the memmove - for y just works fine
for x I have to call it in the loop for ecery line and define how much I want moved
(how many pixels)
line_length x the amount of pixels I want to move

redesign the render function - change the conditions for the nested while loops, make them variables
and then pass the values there
you can put it all in the data struct anyways

arrows don't work with zoom


